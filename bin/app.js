/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const SPARQL_ENDPOINT = 'https://data.adamlink.nl/_api/datasets/menno/alles/services/alles/sparql'\n// const SPARQL_ENDPOINT = 'https://data.adamlink.nl/AdamNet/all/services/endpoint'\nconst SPARQL_HREF = 'https://data.adamlink.nl/AdamNet/all/services/endpoint'\n\nconst PREFIXES = `PREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dct: <http://purl.org/dc/terms/>\nPREFIX geo: <http://www.opengis.net/ont/geosparql#>\nPREFIX sem: <http://semanticweb.cs.vu.nl/2009/11/sem/>\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nPREFIX wdt: <http://www.wikidata.org/prop/direct/>\n`\n\nPERIOD_BOUNDS = {\n  start: 1550,\n  end: (new Date()).getFullYear()\n}\n\nfunction createMapsQuery (data) {\n  const round = (num) => Math.round(num * 100000) / 100000\n\n  let collectionsFilter = ''\n  if (data.collections.length > 0) {\n    const strings = `${data.collections.map(collection => `    \"${collection}\"^^xsd:string`).join(',\\n')}`\n    collectionsFilter = `FILTER (?provenance IN (\\n${strings})\\n  ) .\\n`\n  }\n\n  return `${PREFIXES}\n\nSELECT ?map ?img ?title ?provenance ?begin {\n  ?map dct:spatial ?spatial .\n  ?map foaf:depiction ?img .\n  ?map dc:title ?title .\n  ?map dct:provenance ?provenance .\n  ?map sem:hasBeginTimeStamp ?begin .\n\n  ?spatial dc:type \"outline\"^^xsd:string .\n  ?spatial geo:hasGeometry/geo:asWKT ?wkt .\n  ?spatial wdt:P2046 ?km2 .\n\n  bind (bif:st_geomfromtext(\"POINT(${round(data.coordinates.lng)} ${round(data.coordinates.lat)})\") as ?point)\n  bind (bif:st_geomfromtext(?wkt) as ?outline)\n\n  FILTER (bif:st_intersects(?point, ?outline))\n  FILTER (year(xsd:dateTime(?begin)) >= ${data.period.start}) .\n  FILTER (year(xsd:dateTime(?begin)) <= ${data.period.end}) .\n  ${collectionsFilter}\n}\nORDER BY ASC(?km2)\nLIMIT 25`.trim()\n}\n\nfunction createCollectionsQuery () {\n  return `${PREFIXES}\n\nSELECT DISTINCT ?provenance (COUNT(?map) AS ?count) WHERE {\n  ?map dct:spatial ?spatial .\n  ?map foaf:depiction ?img .\n  ?map dc:title ?title .\n  ?map sem:hasBeginTimeStamp ?begin .\n  ?map dct:provenance ?provenance .\n\n  ?spatial dc:type \"outline\"^^xsd:string .\n  ?spatial geo:hasGeometry/geo:asWKT ?wkt .\n  ?spatial wdt:P2046 ?km2 .\n}\nGROUP BY ?provenance\nORDER BY DESC(?count)\nLIMIT 100\n`.trim()\n}\n\nfunction executeQuery (query) {\n  const queryString = m.buildQueryString({\n    query\n  })\n\n  return fetch(SPARQL_ENDPOINT, {\n    method: 'POST',\n    body: queryString,\n    json: true,\n    headers: {\n      'Accept': 'application/sparql-results+json',\n      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'\n    }\n  })\n    .catch((err) => console.error('Executing query failed', err))\n    .then((response) => response.json())\n    .then((json) => json.results.bindings)\n    .catch((err) => console.error('Parsing results failed', err))\n}\n\nconst RangeSlider = {\n  value: undefined,\n  oncreate: (vnode) => Object.assign(vnode.state, {\n    value: vnode.attrs.value\n  }),\n  view: (vnode) => m('div', {}, [\n    m('label', {\n      for: `range-slider-${vnode.attrs.id}`\n    }, vnode.attrs.label),\n    m('input', {\n      id: `range-slider-${vnode.attrs.id}`,\n      type: 'range',\n      min: vnode.attrs.start,\n      max: vnode.attrs.end,\n      value: vnode.attrs.value,\n      oninput: (event) => {\n        const value = parseInt(event.target.value)\n        vnode.attrs.valueChanged(value)\n      }\n    }),\n    m('span', vnode.attrs.value)\n  ])\n}\n\nconst CollectionsSelect = {\n  collections: undefined,\n  view: (vnode) => [\n    m('label', {\n      for: 'form-collections'\n    }, 'Collecties:'),\n    m('fieldset', {\n      id: 'form-collections',\n      oninput: (event) => {\n        const checkedBoxes = document.querySelectorAll('input[name=form-collections-checkbox]:checked')\n        const values = Array.prototype.map.call(checkedBoxes, (checkbox) => checkbox.value)\n        vnode.attrs.collectionsUpdated(values)\n      }\n    }, vnode.state.collections && vnode.state.collections.map((collection, index) =>\n      m('div', [\n        m('input', {\n          type: 'checkbox',\n          name: 'form-collections-checkbox',\n          id: `form-collections-checkbox-${index}`,\n          value: collection.provenance.value\n        }),\n        m('label', {\n          for: `form-collections-checkbox-${index}`,\n        }, [\n          m('span', collection.provenance.value),\n          m('span', {\n            class: 'form-collections-map-count'\n          }, `${collection.count.value} ${parseInt(collection.count.value) === 1 ? 'kaart' : 'kaarten'}`)\n        ])\n      ])\n    ))\n  ],\n  oncreate: (vnode) => {\n    const query = createCollectionsQuery()\n    executeQuery(query)\n      .then((collections) => {\n        Object.assign(vnode.state, {collections})\n        m.redraw()\n      })\n  }\n}\n\nconst ExecuteButton = {\n  view: (vnode) => m('button', {\n    type: 'submit',\n    onclick: (event) => {\n      if (vnode.attrs.onclick) {\n        vnode.attrs.onclick(event)\n      }\n    }\n  }, 'â–¶ Voer query uit')\n}\n\nconst GeoIntersects = {\n  view: (vnode) => m('div', {\n    id: 'map-container'\n  }, [\n    m(Map, {\n      moveEnd: vnode.attrs.coordinatesUpdated\n    }),\n    m('div', {\n      class: 'map-crosshair'\n    }, [\n      m('img', {\n        src: 'images/crosshair.svg'\n      })\n    ])\n  ])\n}\n\nconst Form = {\n  view: (vnode) => m('li', [\n    m('h2', 'Parameters'),\n    m('form', {\n      onsubmit: (event) => {\n        event.preventDefault()\n        vnode.attrs.executeMapsQuery()\n      }\n    }, [\n      m(CollectionsSelect, {\n        collectionsUpdated: (collections) => {\n          vnode.attrs.data.collections = collections\n          vnode.attrs.formUpdated(vnode.attrs.data)\n        }\n      }),\n      m('div', [\n        m('label', 'Filter kaarten met leeftijd:'),\n        m(RangeSlider, {\n          id: 'start',\n          label: 'Van',\n          start: PERIOD_BOUNDS.start,\n          end: PERIOD_BOUNDS.end,\n          value: vnode.attrs.data.period.start,\n          valueChanged: (value) => {\n           vnode.attrs.data.period.start = value\n           if (vnode.attrs.data.period.end < value) {\n             vnode.attrs.data.period.end = value\n           }\n           vnode.attrs.formUpdated(vnode.attrs.data)\n          }\n        }),\n        m(RangeSlider, {\n          id: 'end',\n          label: 'Tot',\n          start: PERIOD_BOUNDS.start,\n          end: PERIOD_BOUNDS.end,\n          value: vnode.attrs.data.period.end,\n          valueChanged: (value) => {\n            vnode.attrs.data.period.end = value\n            if (vnode.attrs.data.period.start > value) {\n              vnode.attrs.data.period.start = value\n            }\n            vnode.attrs.formUpdated(vnode.attrs.data)\n          }\n        })\n      ]),\n      m('div', [\n        m('label', 'Filter kaarten die dit punt doorkruisen:'),\n        m(GeoIntersects, {\n          coordinatesUpdated: (coordinates) => {\n            vnode.attrs.data.coordinates = {\n              lat: coordinates.lat,\n              lng: coordinates.lng\n            }\n            vnode.attrs.formUpdated(vnode.attrs.data)\n            m.redraw()\n          }\n        }),\n      ]),\n      m('div', {\n        class: 'section-footer',\n      }, [\n        m(ExecuteButton)\n      ])\n    ])\n  ])\n}\n\nconst Map = {\n  view: () => m('div', {\n    id: 'map'\n  }),\n  oncreate: (vnode) => {\n    const map = L.map('map').setView([52.37064, 4.90047], 14)\n\n    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {\n      attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> &copy; <a href=\"http://cartodb.com/attributions\">CartoDB</a>',\n      subdomains: 'abcd',\n      maxZoom: 19\n    }).addTo(map)\n\n    map.on('moveend', (event) => {\n      if (vnode.attrs.moveEnd) {\n        vnode.attrs.moveEnd(map.getCenter())\n      }\n    })\n  }\n}\n\nconst Sparql = {\n  data: {\n    editor: undefined\n  },\n  view: (vnode) => m('li', [\n    m('h2', 'SPARQL-query'),\n    m('textarea', {\n      id: 'sparql-query'\n    }, createMapsQuery(vnode.attrs.data)),\n    m('div', {\n      class: 'section-footer'\n    }, [\n      m('a', {\n        target: '_blank',\n        href: `${SPARQL_HREF}#query=${encodeURIComponent(createMapsQuery(vnode.attrs.data))}&` +\n        `contentTypeConstruct=text%2Fturtle&contentTypeSelect=application%2Fsparql-results%2Bjson&` +\n        `endpoint=${encodeURIComponent(SPARQL_ENDPOINT)}&requestMethod=POST&tabTitle=Query&` +\n        `headers=%7B%7D&outputFormat=table`\n      }, 'Open query in AdamLink'),\n      m(ExecuteButton, {\n        onclick: () => {\n          vnode.attrs.executeMapsQuery()\n        }\n      })\n    ])\n  ]),\n  oncreate: (vnode) => {\n    const element = document.getElementById('sparql-query')\n\n    const editor = CodeMirror.fromTextArea(element, {\n      lineNumbers: true,\n      readOnly: true,\n      mode: 'sparql',\n      foldGutter: true,\n      gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter']\n    })\n\n    editor.foldCode(CodeMirror.Pos(0, 0))\n    vnode.state.data.editor = editor\n  },\n  onupdate: (vnode) => {\n    const editor = vnode.state.data.editor\n    editor.setValue(createMapsQuery(vnode.attrs.data))\n    editor.foldCode(CodeMirror.Pos(0, 0))\n  }\n}\n\nfunction renderResults (data) {\n  if (data && data.length) {\n    return m('ol', {\n      id: 'results'\n    }, data.map((result) => m('li', [\n      m('h3', {\n        class: 'truncate',\n        title: result.title.value\n      }, result.title.value),\n      m('div', {\n        class: 'result-values'\n      }, [\n        m('span', {\n          class: 'truncate',\n        }, result.provenance.value),\n        m('span', result.begin.value.slice(0, 4))\n      ]),\n      m('a', {\n        href: result.map.value\n      }, [\n        m('img', {\n          src: result.img.value\n        })\n      ])\n    ])))\n  } else {\n    return m('p', 'Geen resultaten')\n  }\n}\n\nconst Results =  {\n  view: (vnode) => m('li', [\n    m('h2', 'Resultaten'),\n    renderResults(vnode.attrs.data)\n  ])\n}\n\nfunction executeMapsQuery (vnode) {\n  const query = createMapsQuery(vnode.state.data.form)\n  executeQuery(query)\n    .then((results) => {\n      Object.assign(vnode.state.data, {results})\n      m.redraw()\n    })\n}\n\nconst App = {\n  data: {\n    results: undefined,\n    form: {\n      period: Object.assign({}, PERIOD_BOUNDS),\n      coordinates: {\n        lat: 52.37064,\n        lng: 4.90047\n      },\n      collections: []\n    }\n  },\n  view: (vnode) => ([\n    m('header', [\n      m('img', {\n        src: 'images/header.jpg'\n      }),\n      m('h1', 'Kaart-SPARQL')\n    ]),\n    m('main', [\n      m('p', 'Hier komt de introductie!'),\n      m('ol', {\n        class: 'sections'\n      }, [\n        m(Form, {\n          data: vnode.state.data.form,\n          formUpdated: (form) => Object.assign(vnode.state.data, form),\n          executeMapsQuery: () => executeMapsQuery(vnode)\n        }),\n        m(Sparql, {\n          data: vnode.state.data.form,\n          executeMapsQuery: () => executeMapsQuery(vnode)\n        }),\n        m(Results, {\n          data: vnode.state.data.results\n        })\n      ])\n    ])\n  ])\n}\n\nm.mount(document.body, App)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTUEFSUUxfRU5EUE9JTlQgPSAnaHR0cHM6Ly9kYXRhLmFkYW1saW5rLm5sL19hcGkvZGF0YXNldHMvbWVubm8vYWxsZXMvc2VydmljZXMvYWxsZXMvc3BhcnFsJ1xuLy8gY29uc3QgU1BBUlFMX0VORFBPSU5UID0gJ2h0dHBzOi8vZGF0YS5hZGFtbGluay5ubC9BZGFtTmV0L2FsbC9zZXJ2aWNlcy9lbmRwb2ludCdcbmNvbnN0IFNQQVJRTF9IUkVGID0gJ2h0dHBzOi8vZGF0YS5hZGFtbGluay5ubC9BZGFtTmV0L2FsbC9zZXJ2aWNlcy9lbmRwb2ludCdcblxuY29uc3QgUFJFRklYRVMgPSBgUFJFRklYIGRjOiA8aHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8+XG5QUkVGSVggZGN0OiA8aHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zLz5cblBSRUZJWCBnZW86IDxodHRwOi8vd3d3Lm9wZW5naXMubmV0L29udC9nZW9zcGFycWwjPlxuUFJFRklYIHNlbTogPGh0dHA6Ly9zZW1hbnRpY3dlYi5jcy52dS5ubC8yMDA5LzExL3NlbS8+XG5QUkVGSVggZm9hZjogPGh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvPlxuUFJFRklYIHdkdDogPGh0dHA6Ly93d3cud2lraWRhdGEub3JnL3Byb3AvZGlyZWN0Lz5cbmBcblxuUEVSSU9EX0JPVU5EUyA9IHtcbiAgc3RhcnQ6IDE1NTAsXG4gIGVuZDogKG5ldyBEYXRlKCkpLmdldEZ1bGxZZWFyKClcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFwc1F1ZXJ5IChkYXRhKSB7XG4gIGNvbnN0IHJvdW5kID0gKG51bSkgPT4gTWF0aC5yb3VuZChudW0gKiAxMDAwMDApIC8gMTAwMDAwXG5cbiAgbGV0IGNvbGxlY3Rpb25zRmlsdGVyID0gJydcbiAgaWYgKGRhdGEuY29sbGVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0cmluZ3MgPSBgJHtkYXRhLmNvbGxlY3Rpb25zLm1hcChjb2xsZWN0aW9uID0+IGAgICAgXCIke2NvbGxlY3Rpb259XCJeXnhzZDpzdHJpbmdgKS5qb2luKCcsXFxuJyl9YFxuICAgIGNvbGxlY3Rpb25zRmlsdGVyID0gYEZJTFRFUiAoP3Byb3ZlbmFuY2UgSU4gKFxcbiR7c3RyaW5nc30pXFxuICApIC5cXG5gXG4gIH1cblxuICByZXR1cm4gYCR7UFJFRklYRVN9XG5cblNFTEVDVCA/bWFwID9pbWcgP3RpdGxlID9wcm92ZW5hbmNlID9iZWdpbiB7XG4gID9tYXAgZGN0OnNwYXRpYWwgP3NwYXRpYWwgLlxuICA/bWFwIGZvYWY6ZGVwaWN0aW9uID9pbWcgLlxuICA/bWFwIGRjOnRpdGxlID90aXRsZSAuXG4gID9tYXAgZGN0OnByb3ZlbmFuY2UgP3Byb3ZlbmFuY2UgLlxuICA/bWFwIHNlbTpoYXNCZWdpblRpbWVTdGFtcCA/YmVnaW4gLlxuXG4gID9zcGF0aWFsIGRjOnR5cGUgXCJvdXRsaW5lXCJeXnhzZDpzdHJpbmcgLlxuICA/c3BhdGlhbCBnZW86aGFzR2VvbWV0cnkvZ2VvOmFzV0tUID93a3QgLlxuICA/c3BhdGlhbCB3ZHQ6UDIwNDYgP2ttMiAuXG5cbiAgYmluZCAoYmlmOnN0X2dlb21mcm9tdGV4dChcIlBPSU5UKCR7cm91bmQoZGF0YS5jb29yZGluYXRlcy5sbmcpfSAke3JvdW5kKGRhdGEuY29vcmRpbmF0ZXMubGF0KX0pXCIpIGFzID9wb2ludClcbiAgYmluZCAoYmlmOnN0X2dlb21mcm9tdGV4dCg/d2t0KSBhcyA/b3V0bGluZSlcblxuICBGSUxURVIgKGJpZjpzdF9pbnRlcnNlY3RzKD9wb2ludCwgP291dGxpbmUpKVxuICBGSUxURVIgKHllYXIoeHNkOmRhdGVUaW1lKD9iZWdpbikpID49ICR7ZGF0YS5wZXJpb2Quc3RhcnR9KSAuXG4gIEZJTFRFUiAoeWVhcih4c2Q6ZGF0ZVRpbWUoP2JlZ2luKSkgPD0gJHtkYXRhLnBlcmlvZC5lbmR9KSAuXG4gICR7Y29sbGVjdGlvbnNGaWx0ZXJ9XG59XG5PUkRFUiBCWSBBU0MoP2ttMilcbkxJTUlUIDI1YC50cmltKClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbnNRdWVyeSAoKSB7XG4gIHJldHVybiBgJHtQUkVGSVhFU31cblxuU0VMRUNUIERJU1RJTkNUID9wcm92ZW5hbmNlIChDT1VOVCg/bWFwKSBBUyA/Y291bnQpIFdIRVJFIHtcbiAgP21hcCBkY3Q6c3BhdGlhbCA/c3BhdGlhbCAuXG4gID9tYXAgZm9hZjpkZXBpY3Rpb24gP2ltZyAuXG4gID9tYXAgZGM6dGl0bGUgP3RpdGxlIC5cbiAgP21hcCBzZW06aGFzQmVnaW5UaW1lU3RhbXAgP2JlZ2luIC5cbiAgP21hcCBkY3Q6cHJvdmVuYW5jZSA/cHJvdmVuYW5jZSAuXG5cbiAgP3NwYXRpYWwgZGM6dHlwZSBcIm91dGxpbmVcIl5eeHNkOnN0cmluZyAuXG4gID9zcGF0aWFsIGdlbzpoYXNHZW9tZXRyeS9nZW86YXNXS1QgP3drdCAuXG4gID9zcGF0aWFsIHdkdDpQMjA0NiA/a20yIC5cbn1cbkdST1VQIEJZID9wcm92ZW5hbmNlXG5PUkRFUiBCWSBERVNDKD9jb3VudClcbkxJTUlUIDEwMFxuYC50cmltKClcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVF1ZXJ5IChxdWVyeSkge1xuICBjb25zdCBxdWVyeVN0cmluZyA9IG0uYnVpbGRRdWVyeVN0cmluZyh7XG4gICAgcXVlcnlcbiAgfSlcblxuICByZXR1cm4gZmV0Y2goU1BBUlFMX0VORFBPSU5ULCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgYm9keTogcXVlcnlTdHJpbmcsXG4gICAganNvbjogdHJ1ZSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnXG4gICAgfVxuICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKCdFeGVjdXRpbmcgcXVlcnkgZmFpbGVkJywgZXJyKSlcbiAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAudGhlbigoanNvbikgPT4ganNvbi5yZXN1bHRzLmJpbmRpbmdzKVxuICAgIC5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKCdQYXJzaW5nIHJlc3VsdHMgZmFpbGVkJywgZXJyKSlcbn1cblxuY29uc3QgUmFuZ2VTbGlkZXIgPSB7XG4gIHZhbHVlOiB1bmRlZmluZWQsXG4gIG9uY3JlYXRlOiAodm5vZGUpID0+IE9iamVjdC5hc3NpZ24odm5vZGUuc3RhdGUsIHtcbiAgICB2YWx1ZTogdm5vZGUuYXR0cnMudmFsdWVcbiAgfSksXG4gIHZpZXc6ICh2bm9kZSkgPT4gbSgnZGl2Jywge30sIFtcbiAgICBtKCdsYWJlbCcsIHtcbiAgICAgIGZvcjogYHJhbmdlLXNsaWRlci0ke3Zub2RlLmF0dHJzLmlkfWBcbiAgICB9LCB2bm9kZS5hdHRycy5sYWJlbCksXG4gICAgbSgnaW5wdXQnLCB7XG4gICAgICBpZDogYHJhbmdlLXNsaWRlci0ke3Zub2RlLmF0dHJzLmlkfWAsXG4gICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgbWluOiB2bm9kZS5hdHRycy5zdGFydCxcbiAgICAgIG1heDogdm5vZGUuYXR0cnMuZW5kLFxuICAgICAgdmFsdWU6IHZub2RlLmF0dHJzLnZhbHVlLFxuICAgICAgb25pbnB1dDogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgICAgICB2bm9kZS5hdHRycy52YWx1ZUNoYW5nZWQodmFsdWUpXG4gICAgICB9XG4gICAgfSksXG4gICAgbSgnc3BhbicsIHZub2RlLmF0dHJzLnZhbHVlKVxuICBdKVxufVxuXG5jb25zdCBDb2xsZWN0aW9uc1NlbGVjdCA9IHtcbiAgY29sbGVjdGlvbnM6IHVuZGVmaW5lZCxcbiAgdmlldzogKHZub2RlKSA9PiBbXG4gICAgbSgnbGFiZWwnLCB7XG4gICAgICBmb3I6ICdmb3JtLWNvbGxlY3Rpb25zJ1xuICAgIH0sICdDb2xsZWN0aWVzOicpLFxuICAgIG0oJ2ZpZWxkc2V0Jywge1xuICAgICAgaWQ6ICdmb3JtLWNvbGxlY3Rpb25zJyxcbiAgICAgIG9uaW5wdXQ6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja2VkQm94ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPWZvcm0tY29sbGVjdGlvbnMtY2hlY2tib3hdOmNoZWNrZWQnKVxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoY2hlY2tlZEJveGVzLCAoY2hlY2tib3gpID0+IGNoZWNrYm94LnZhbHVlKVxuICAgICAgICB2bm9kZS5hdHRycy5jb2xsZWN0aW9uc1VwZGF0ZWQodmFsdWVzKVxuICAgICAgfVxuICAgIH0sIHZub2RlLnN0YXRlLmNvbGxlY3Rpb25zICYmIHZub2RlLnN0YXRlLmNvbGxlY3Rpb25zLm1hcCgoY29sbGVjdGlvbiwgaW5kZXgpID0+XG4gICAgICBtKCdkaXYnLCBbXG4gICAgICAgIG0oJ2lucHV0Jywge1xuICAgICAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICAgICAgbmFtZTogJ2Zvcm0tY29sbGVjdGlvbnMtY2hlY2tib3gnLFxuICAgICAgICAgIGlkOiBgZm9ybS1jb2xsZWN0aW9ucy1jaGVja2JveC0ke2luZGV4fWAsXG4gICAgICAgICAgdmFsdWU6IGNvbGxlY3Rpb24ucHJvdmVuYW5jZS52YWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgbSgnbGFiZWwnLCB7XG4gICAgICAgICAgZm9yOiBgZm9ybS1jb2xsZWN0aW9ucy1jaGVja2JveC0ke2luZGV4fWAsXG4gICAgICAgIH0sIFtcbiAgICAgICAgICBtKCdzcGFuJywgY29sbGVjdGlvbi5wcm92ZW5hbmNlLnZhbHVlKSxcbiAgICAgICAgICBtKCdzcGFuJywge1xuICAgICAgICAgICAgY2xhc3M6ICdmb3JtLWNvbGxlY3Rpb25zLW1hcC1jb3VudCdcbiAgICAgICAgICB9LCBgJHtjb2xsZWN0aW9uLmNvdW50LnZhbHVlfSAke3BhcnNlSW50KGNvbGxlY3Rpb24uY291bnQudmFsdWUpID09PSAxID8gJ2thYXJ0JyA6ICdrYWFydGVuJ31gKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICApKVxuICBdLFxuICBvbmNyZWF0ZTogKHZub2RlKSA9PiB7XG4gICAgY29uc3QgcXVlcnkgPSBjcmVhdGVDb2xsZWN0aW9uc1F1ZXJ5KClcbiAgICBleGVjdXRlUXVlcnkocXVlcnkpXG4gICAgICAudGhlbigoY29sbGVjdGlvbnMpID0+IHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih2bm9kZS5zdGF0ZSwge2NvbGxlY3Rpb25zfSlcbiAgICAgICAgbS5yZWRyYXcoKVxuICAgICAgfSlcbiAgfVxufVxuXG5jb25zdCBFeGVjdXRlQnV0dG9uID0ge1xuICB2aWV3OiAodm5vZGUpID0+IG0oJ2J1dHRvbicsIHtcbiAgICB0eXBlOiAnc3VibWl0JyxcbiAgICBvbmNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgIGlmICh2bm9kZS5hdHRycy5vbmNsaWNrKSB7XG4gICAgICAgIHZub2RlLmF0dHJzLm9uY2xpY2soZXZlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCAn4pa2IFZvZXIgcXVlcnkgdWl0Jylcbn1cblxuY29uc3QgR2VvSW50ZXJzZWN0cyA9IHtcbiAgdmlldzogKHZub2RlKSA9PiBtKCdkaXYnLCB7XG4gICAgaWQ6ICdtYXAtY29udGFpbmVyJ1xuICB9LCBbXG4gICAgbShNYXAsIHtcbiAgICAgIG1vdmVFbmQ6IHZub2RlLmF0dHJzLmNvb3JkaW5hdGVzVXBkYXRlZFxuICAgIH0pLFxuICAgIG0oJ2RpdicsIHtcbiAgICAgIGNsYXNzOiAnbWFwLWNyb3NzaGFpcidcbiAgICB9LCBbXG4gICAgICBtKCdpbWcnLCB7XG4gICAgICAgIHNyYzogJ2ltYWdlcy9jcm9zc2hhaXIuc3ZnJ1xuICAgICAgfSlcbiAgICBdKVxuICBdKVxufVxuXG5jb25zdCBGb3JtID0ge1xuICB2aWV3OiAodm5vZGUpID0+IG0oJ2xpJywgW1xuICAgIG0oJ2gyJywgJ1BhcmFtZXRlcnMnKSxcbiAgICBtKCdmb3JtJywge1xuICAgICAgb25zdWJtaXQ6IChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHZub2RlLmF0dHJzLmV4ZWN1dGVNYXBzUXVlcnkoKVxuICAgICAgfVxuICAgIH0sIFtcbiAgICAgIG0oQ29sbGVjdGlvbnNTZWxlY3QsIHtcbiAgICAgICAgY29sbGVjdGlvbnNVcGRhdGVkOiAoY29sbGVjdGlvbnMpID0+IHtcbiAgICAgICAgICB2bm9kZS5hdHRycy5kYXRhLmNvbGxlY3Rpb25zID0gY29sbGVjdGlvbnNcbiAgICAgICAgICB2bm9kZS5hdHRycy5mb3JtVXBkYXRlZCh2bm9kZS5hdHRycy5kYXRhKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIG0oJ2RpdicsIFtcbiAgICAgICAgbSgnbGFiZWwnLCAnRmlsdGVyIGthYXJ0ZW4gbWV0IGxlZWZ0aWpkOicpLFxuICAgICAgICBtKFJhbmdlU2xpZGVyLCB7XG4gICAgICAgICAgaWQ6ICdzdGFydCcsXG4gICAgICAgICAgbGFiZWw6ICdWYW4nLFxuICAgICAgICAgIHN0YXJ0OiBQRVJJT0RfQk9VTkRTLnN0YXJ0LFxuICAgICAgICAgIGVuZDogUEVSSU9EX0JPVU5EUy5lbmQsXG4gICAgICAgICAgdmFsdWU6IHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLnN0YXJ0LFxuICAgICAgICAgIHZhbHVlQ2hhbmdlZDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgIHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLnN0YXJ0ID0gdmFsdWVcbiAgICAgICAgICAgaWYgKHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLmVuZCA8IHZhbHVlKSB7XG4gICAgICAgICAgICAgdm5vZGUuYXR0cnMuZGF0YS5wZXJpb2QuZW5kID0gdmFsdWVcbiAgICAgICAgICAgfVxuICAgICAgICAgICB2bm9kZS5hdHRycy5mb3JtVXBkYXRlZCh2bm9kZS5hdHRycy5kYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG0oUmFuZ2VTbGlkZXIsIHtcbiAgICAgICAgICBpZDogJ2VuZCcsXG4gICAgICAgICAgbGFiZWw6ICdUb3QnLFxuICAgICAgICAgIHN0YXJ0OiBQRVJJT0RfQk9VTkRTLnN0YXJ0LFxuICAgICAgICAgIGVuZDogUEVSSU9EX0JPVU5EUy5lbmQsXG4gICAgICAgICAgdmFsdWU6IHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLmVuZCxcbiAgICAgICAgICB2YWx1ZUNoYW5nZWQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdm5vZGUuYXR0cnMuZGF0YS5wZXJpb2QuZW5kID0gdmFsdWVcbiAgICAgICAgICAgIGlmICh2bm9kZS5hdHRycy5kYXRhLnBlcmlvZC5zdGFydCA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLnN0YXJ0ID0gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZub2RlLmF0dHJzLmZvcm1VcGRhdGVkKHZub2RlLmF0dHJzLmRhdGEpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBtKCdkaXYnLCBbXG4gICAgICAgIG0oJ2xhYmVsJywgJ0ZpbHRlciBrYWFydGVuIGRpZSBkaXQgcHVudCBkb29ya3J1aXNlbjonKSxcbiAgICAgICAgbShHZW9JbnRlcnNlY3RzLCB7XG4gICAgICAgICAgY29vcmRpbmF0ZXNVcGRhdGVkOiAoY29vcmRpbmF0ZXMpID0+IHtcbiAgICAgICAgICAgIHZub2RlLmF0dHJzLmRhdGEuY29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgICAgIGxhdDogY29vcmRpbmF0ZXMubGF0LFxuICAgICAgICAgICAgICBsbmc6IGNvb3JkaW5hdGVzLmxuZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUuYXR0cnMuZm9ybVVwZGF0ZWQodm5vZGUuYXR0cnMuZGF0YSlcbiAgICAgICAgICAgIG0ucmVkcmF3KClcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgICBtKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAnc2VjdGlvbi1mb290ZXInLFxuICAgICAgfSwgW1xuICAgICAgICBtKEV4ZWN1dGVCdXR0b24pXG4gICAgICBdKVxuICAgIF0pXG4gIF0pXG59XG5cbmNvbnN0IE1hcCA9IHtcbiAgdmlldzogKCkgPT4gbSgnZGl2Jywge1xuICAgIGlkOiAnbWFwJ1xuICB9KSxcbiAgb25jcmVhdGU6ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IEwubWFwKCdtYXAnKS5zZXRWaWV3KFs1Mi4zNzA2NCwgNC45MDA0N10sIDE0KVxuXG4gICAgTC50aWxlTGF5ZXIoJ2h0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy17c30uZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X2FsbC97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiAmY29weTsgPGEgaHJlZj1cImh0dHA6Ly9jYXJ0b2RiLmNvbS9hdHRyaWJ1dGlvbnNcIj5DYXJ0b0RCPC9hPicsXG4gICAgICBzdWJkb21haW5zOiAnYWJjZCcsXG4gICAgICBtYXhab29tOiAxOVxuICAgIH0pLmFkZFRvKG1hcClcblxuICAgIG1hcC5vbignbW92ZWVuZCcsIChldmVudCkgPT4ge1xuICAgICAgaWYgKHZub2RlLmF0dHJzLm1vdmVFbmQpIHtcbiAgICAgICAgdm5vZGUuYXR0cnMubW92ZUVuZChtYXAuZ2V0Q2VudGVyKCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBTcGFycWwgPSB7XG4gIGRhdGE6IHtcbiAgICBlZGl0b3I6IHVuZGVmaW5lZFxuICB9LFxuICB2aWV3OiAodm5vZGUpID0+IG0oJ2xpJywgW1xuICAgIG0oJ2gyJywgJ1NQQVJRTC1xdWVyeScpLFxuICAgIG0oJ3RleHRhcmVhJywge1xuICAgICAgaWQ6ICdzcGFycWwtcXVlcnknXG4gICAgfSwgY3JlYXRlTWFwc1F1ZXJ5KHZub2RlLmF0dHJzLmRhdGEpKSxcbiAgICBtKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3NlY3Rpb24tZm9vdGVyJ1xuICAgIH0sIFtcbiAgICAgIG0oJ2EnLCB7XG4gICAgICAgIHRhcmdldDogJ19ibGFuaycsXG4gICAgICAgIGhyZWY6IGAke1NQQVJRTF9IUkVGfSNxdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChjcmVhdGVNYXBzUXVlcnkodm5vZGUuYXR0cnMuZGF0YSkpfSZgICtcbiAgICAgICAgYGNvbnRlbnRUeXBlQ29uc3RydWN0PXRleHQlMkZ0dXJ0bGUmY29udGVudFR5cGVTZWxlY3Q9YXBwbGljYXRpb24lMkZzcGFycWwtcmVzdWx0cyUyQmpzb24mYCArXG4gICAgICAgIGBlbmRwb2ludD0ke2VuY29kZVVSSUNvbXBvbmVudChTUEFSUUxfRU5EUE9JTlQpfSZyZXF1ZXN0TWV0aG9kPVBPU1QmdGFiVGl0bGU9UXVlcnkmYCArXG4gICAgICAgIGBoZWFkZXJzPSU3QiU3RCZvdXRwdXRGb3JtYXQ9dGFibGVgXG4gICAgICB9LCAnT3BlbiBxdWVyeSBpbiBBZGFtTGluaycpLFxuICAgICAgbShFeGVjdXRlQnV0dG9uLCB7XG4gICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICB2bm9kZS5hdHRycy5leGVjdXRlTWFwc1F1ZXJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdKVxuICBdKSxcbiAgb25jcmVhdGU6ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BhcnFsLXF1ZXJ5JylcblxuICAgIGNvbnN0IGVkaXRvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsZW1lbnQsIHtcbiAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICBtb2RlOiAnc3BhcnFsJyxcbiAgICAgIGZvbGRHdXR0ZXI6IHRydWUsXG4gICAgICBndXR0ZXJzOiBbJ0NvZGVNaXJyb3ItbGluZW51bWJlcnMnLCAnQ29kZU1pcnJvci1mb2xkZ3V0dGVyJ11cbiAgICB9KVxuXG4gICAgZWRpdG9yLmZvbGRDb2RlKENvZGVNaXJyb3IuUG9zKDAsIDApKVxuICAgIHZub2RlLnN0YXRlLmRhdGEuZWRpdG9yID0gZWRpdG9yXG4gIH0sXG4gIG9udXBkYXRlOiAodm5vZGUpID0+IHtcbiAgICBjb25zdCBlZGl0b3IgPSB2bm9kZS5zdGF0ZS5kYXRhLmVkaXRvclxuICAgIGVkaXRvci5zZXRWYWx1ZShjcmVhdGVNYXBzUXVlcnkodm5vZGUuYXR0cnMuZGF0YSkpXG4gICAgZWRpdG9yLmZvbGRDb2RlKENvZGVNaXJyb3IuUG9zKDAsIDApKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJlc3VsdHMgKGRhdGEpIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbSgnb2wnLCB7XG4gICAgICBpZDogJ3Jlc3VsdHMnXG4gICAgfSwgZGF0YS5tYXAoKHJlc3VsdCkgPT4gbSgnbGknLCBbXG4gICAgICBtKCdoMycsIHtcbiAgICAgICAgY2xhc3M6ICd0cnVuY2F0ZScsXG4gICAgICAgIHRpdGxlOiByZXN1bHQudGl0bGUudmFsdWVcbiAgICAgIH0sIHJlc3VsdC50aXRsZS52YWx1ZSksXG4gICAgICBtKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAncmVzdWx0LXZhbHVlcydcbiAgICAgIH0sIFtcbiAgICAgICAgbSgnc3BhbicsIHtcbiAgICAgICAgICBjbGFzczogJ3RydW5jYXRlJyxcbiAgICAgICAgfSwgcmVzdWx0LnByb3ZlbmFuY2UudmFsdWUpLFxuICAgICAgICBtKCdzcGFuJywgcmVzdWx0LmJlZ2luLnZhbHVlLnNsaWNlKDAsIDQpKVxuICAgICAgXSksXG4gICAgICBtKCdhJywge1xuICAgICAgICBocmVmOiByZXN1bHQubWFwLnZhbHVlXG4gICAgICB9LCBbXG4gICAgICAgIG0oJ2ltZycsIHtcbiAgICAgICAgICBzcmM6IHJlc3VsdC5pbWcudmFsdWVcbiAgICAgICAgfSlcbiAgICAgIF0pXG4gICAgXSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtKCdwJywgJ0dlZW4gcmVzdWx0YXRlbicpXG4gIH1cbn1cblxuY29uc3QgUmVzdWx0cyA9ICB7XG4gIHZpZXc6ICh2bm9kZSkgPT4gbSgnbGknLCBbXG4gICAgbSgnaDInLCAnUmVzdWx0YXRlbicpLFxuICAgIHJlbmRlclJlc3VsdHModm5vZGUuYXR0cnMuZGF0YSlcbiAgXSlcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZU1hcHNRdWVyeSAodm5vZGUpIHtcbiAgY29uc3QgcXVlcnkgPSBjcmVhdGVNYXBzUXVlcnkodm5vZGUuc3RhdGUuZGF0YS5mb3JtKVxuICBleGVjdXRlUXVlcnkocXVlcnkpXG4gICAgLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24odm5vZGUuc3RhdGUuZGF0YSwge3Jlc3VsdHN9KVxuICAgICAgbS5yZWRyYXcoKVxuICAgIH0pXG59XG5cbmNvbnN0IEFwcCA9IHtcbiAgZGF0YToge1xuICAgIHJlc3VsdHM6IHVuZGVmaW5lZCxcbiAgICBmb3JtOiB7XG4gICAgICBwZXJpb2Q6IE9iamVjdC5hc3NpZ24oe30sIFBFUklPRF9CT1VORFMpLFxuICAgICAgY29vcmRpbmF0ZXM6IHtcbiAgICAgICAgbGF0OiA1Mi4zNzA2NCxcbiAgICAgICAgbG5nOiA0LjkwMDQ3XG4gICAgICB9LFxuICAgICAgY29sbGVjdGlvbnM6IFtdXG4gICAgfVxuICB9LFxuICB2aWV3OiAodm5vZGUpID0+IChbXG4gICAgbSgnaGVhZGVyJywgW1xuICAgICAgbSgnaW1nJywge1xuICAgICAgICBzcmM6ICdpbWFnZXMvaGVhZGVyLmpwZydcbiAgICAgIH0pLFxuICAgICAgbSgnaDEnLCAnS2FhcnQtU1BBUlFMJylcbiAgICBdKSxcbiAgICBtKCdtYWluJywgW1xuICAgICAgbSgncCcsICdIaWVyIGtvbXQgZGUgaW50cm9kdWN0aWUhJyksXG4gICAgICBtKCdvbCcsIHtcbiAgICAgICAgY2xhc3M6ICdzZWN0aW9ucydcbiAgICAgIH0sIFtcbiAgICAgICAgbShGb3JtLCB7XG4gICAgICAgICAgZGF0YTogdm5vZGUuc3RhdGUuZGF0YS5mb3JtLFxuICAgICAgICAgIGZvcm1VcGRhdGVkOiAoZm9ybSkgPT4gT2JqZWN0LmFzc2lnbih2bm9kZS5zdGF0ZS5kYXRhLCBmb3JtKSxcbiAgICAgICAgICBleGVjdXRlTWFwc1F1ZXJ5OiAoKSA9PiBleGVjdXRlTWFwc1F1ZXJ5KHZub2RlKVxuICAgICAgICB9KSxcbiAgICAgICAgbShTcGFycWwsIHtcbiAgICAgICAgICBkYXRhOiB2bm9kZS5zdGF0ZS5kYXRhLmZvcm0sXG4gICAgICAgICAgZXhlY3V0ZU1hcHNRdWVyeTogKCkgPT4gZXhlY3V0ZU1hcHNRdWVyeSh2bm9kZSlcbiAgICAgICAgfSksXG4gICAgICAgIG0oUmVzdWx0cywge1xuICAgICAgICAgIGRhdGE6IHZub2RlLnN0YXRlLmRhdGEucmVzdWx0c1xuICAgICAgICB9KVxuICAgICAgXSlcbiAgICBdKVxuICBdKVxufVxuXG5tLm1vdW50KGRvY3VtZW50LmJvZHksIEFwcClcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });