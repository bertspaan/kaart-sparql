/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const SPARQL_ENDPOINT = 'https://data.adamlink.nl/_api/datasets/menno/alles/services/alles/sparql'\n// const SPARQL_ENDPOINT = 'https://data.adamlink.nl/AdamNet/all/services/endpoint'\nconst SPARQL_HREF = 'https://data.adamlink.nl/AdamNet/all/services/endpoint'\n\nconst PREFIXES = `PREFIX dc: <http://purl.org/dc/elements/1.1/>\nPREFIX dct: <http://purl.org/dc/terms/>\nPREFIX geo: <http://www.opengis.net/ont/geosparql#>\nPREFIX sem: <http://semanticweb.cs.vu.nl/2009/11/sem/>\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\nPREFIX wdt: <http://www.wikidata.org/prop/direct/>\n`.trim()\n\nPERIOD_BOUNDS = {\n  start: 1550,\n  end: (new Date()).getFullYear()\n}\n\nfunction createMapsQuery (data) {\n  const round = (num) => Math.round(num * 100000) / 100000\n\n  let collectionsFilter = ''\n  if (data.collections.length === 1) {\n    collectionsFilter = `?map dct:provenance \"${data.collections[0]}\"^^xsd:string .\\n`\n  } else if (data.collections.length > 1) {\n    const strings = `${data.collections.map(collection => `    \"${collection}\"^^xsd:string`).join(',\\n')}`\n    collectionsFilter = `\\n  FILTER (?provenance IN (\\n${strings})\\n  ) .`\n  }\n\n  let creatorFilter = ''\n  if (data.creator.length > 1) {\n    // Escape double quotes\n    const regex = data.creator.replace(/\\\\([\\s\\S])|(\")/g, '\\\\$1$2')\n    creatorFilter = `FILTER REGEX(?creator, \"${regex}\", \"i\") .`\n  }\n\n  return `${PREFIXES}\n\nSELECT ?map ?img ?title ?provenance ?creator ?begin {\n  ?map dct:spatial ?spatial .\n  ?map foaf:depiction ?img .\n  ?map dc:title ?title .\n  ?map dct:provenance ?provenance .\n  ?map dc:creator ?creator .\n  ?map sem:hasBeginTimeStamp ?begin .\n\n  ?spatial dc:type \"outline\"^^xsd:string .\n  ?spatial geo:hasGeometry/geo:asWKT ?wkt .\n  ?spatial wdt:P2046 ?km2 .\n  ${collectionsFilter}\n  ${creatorFilter}\n  FILTER (year(xsd:dateTime(?begin)) >= ${data.period.start}) .\n  FILTER (year(xsd:dateTime(?begin)) <= ${data.period.end}) .\n  bind (bif:st_geomfromtext(\"POINT(${round(data.coordinates.lng)} ${round(data.coordinates.lat)})\") as ?point)\n  bind (bif:st_geomfromtext(?wkt) as ?outline)\n  FILTER (bif:st_intersects(?point, ?outline))\n}\nORDER BY ASC(?km2)\nLIMIT 25`.trim()\n}\n\nfunction createCollectionsQuery () {\n  return `${PREFIXES}\n\nSELECT DISTINCT ?provenance (COUNT(?map) AS ?count) WHERE {\n  ?map dct:spatial ?spatial .\n  ?map foaf:depiction ?img .\n  ?map dc:title ?title .\n  ?map sem:hasBeginTimeStamp ?begin .\n  ?map dct:provenance ?provenance .\n\n  ?spatial dc:type \"outline\"^^xsd:string .\n  ?spatial geo:hasGeometry/geo:asWKT ?wkt .\n  ?spatial wdt:P2046 ?km2 .\n}\nGROUP BY ?provenance\nORDER BY DESC(?count)\nLIMIT 100\n`.trim()\n}\n\nfunction executeQuery (query) {\n  const queryString = m.buildQueryString({\n    query\n  })\n\n  return fetch(SPARQL_ENDPOINT, {\n    method: 'POST',\n    body: queryString,\n    json: true,\n    headers: {\n      'Accept': 'application/sparql-results+json',\n      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'\n    }\n  })\n    .catch((err) => console.error('Executing query failed', err))\n    .then((response) => response.json())\n    .then((json) => json.results.bindings)\n    .catch((err) => console.error('Parsing results failed', err))\n}\n\nconst RangeSlider = {\n  value: undefined,\n  oncreate: (vnode) => Object.assign(vnode.state, {\n    value: vnode.attrs.value\n  }),\n  view: (vnode) => m('div', {\n    class: 'range-slider'\n  }, [\n    m('label', {\n      for: `range-slider-${vnode.attrs.id}`\n    }, `${vnode.attrs.label} ${vnode.attrs.value}`),\n    m('input', {\n      id: `range-slider-${vnode.attrs.id}`,\n      type: 'range',\n      min: vnode.attrs.start,\n      max: vnode.attrs.end,\n      value: vnode.attrs.value,\n      oninput: (event) => {\n        const value = parseInt(event.target.value)\n        vnode.attrs.valueChanged(value)\n      }\n    })\n  ])\n}\n\nconst CollectionsSelect = {\n  collections: undefined,\n  view: (vnode) => [\n    m('fieldset', {\n      id: 'form-collections',\n      onchange: (event) => {\n        const checkBoxes = document.querySelectorAll('input[name=form-collections-checkbox]:checked')\n        const values = Array.prototype.map.call(checkBoxes, (checkbox) => checkbox.value)\n\n        vnode.attrs.collectionsUpdated(values)\n      }\n    }, vnode.state.collections && vnode.state.collections.map((collection, index) =>\n      m('div', [\n        m('input', {\n          type: 'checkbox',\n          name: 'form-collections-checkbox',\n          id: `form-collections-checkbox-${index}`,\n          value: collection.provenance.value\n        }),\n        m('label', {\n          for: `form-collections-checkbox-${index}`,\n        }, [\n          m('span', collection.provenance.value),\n          m('span', {\n            class: 'form-collections-map-count'\n          }, `${collection.count.value} ${parseInt(collection.count.value) === 1 ? 'kaart' : 'kaarten'}`)\n        ])\n      ])\n    ))\n  ],\n  oncreate: (vnode) => {\n    const query = createCollectionsQuery()\n    executeQuery(query)\n      .then((collections) => {\n        Object.assign(vnode.state, {collections})\n        m.redraw()\n      })\n  }\n}\n\nconst ExecuteButton = {\n  view: (vnode) => m('button', {\n    type: 'submit',\n    onclick: (event) => {\n      if (vnode.attrs.onclick) {\n        vnode.attrs.onclick(event)\n      }\n    }\n  }, 'â–¶ Voer query uit')\n}\n\nconst GeoIntersects = {\n  view: (vnode) => m('div', {\n    id: 'map-container'\n  }, [\n    m(Map, {\n      moveEnd: vnode.attrs.coordinatesUpdated\n    }),\n    m('div', {\n      class: 'map-crosshair'\n    }, [\n      m('img', {\n        src: 'images/crosshair.svg'\n      })\n    ])\n  ])\n}\n\nconst Form = {\n  view: (vnode) => m('li', [\n    m('h2', 'Parameters'),\n    m('form', {\n      onsubmit: (event) => {\n        event.preventDefault()\n        vnode.attrs.executeMapsQuery()\n      }\n    }, [\n      m('div', [\n        m('label', {\n          for: 'form-collections',\n          class: 'filter-label'\n        }, 'Laat kaarten uit deze collecties zien:'),\n        m('div', {\n          class: 'filter'\n        }, [\n          m(CollectionsSelect, {\n            collectionsUpdated: (collections) => {\n              vnode.attrs.data.collections = collections\n              vnode.attrs.formUpdated(vnode.attrs.data)\n            }\n          })\n        ])\n      ]),\n      m('div', [\n        m('label', {\n          class: 'filter-label'\n        }, 'Laat kaarten van deze maker zien:'),\n        m('div', {\n          class: 'filter'\n        }, [\n          m('input', {\n            value: vnode.attrs.data.creator,\n            type: 'text',\n            oninput: (event) => {\n              const value = event.target.value\n              vnode.attrs.data.creator = value\n              vnode.attrs.formUpdated(vnode.attrs.data)\n            },\n            placeHolder: 'Zoek op exacte tekst, of gebruik een reguliere expressie'\n          })\n        ])\n      ]),\n      m('div', [\n        m('label', {\n          class: 'filter-label'\n        }, 'Laat kaarten zien uit deze periode:'),\n        m('div', {\n          id: 'period-filter',\n          class: 'filter'\n        }, [\n          m(RangeSlider, {\n            id: 'start',\n            label: 'Van',\n            start: PERIOD_BOUNDS.start,\n            end: PERIOD_BOUNDS.end,\n            value: vnode.attrs.data.period.start,\n            valueChanged: (value) => {\n             vnode.attrs.data.period.start = value\n             if (vnode.attrs.data.period.end < value) {\n               vnode.attrs.data.period.end = value\n             }\n             vnode.attrs.formUpdated(vnode.attrs.data)\n            }\n          }),\n          m(RangeSlider, {\n            id: 'end',\n            label: '; tot',\n            start: PERIOD_BOUNDS.start,\n            end: PERIOD_BOUNDS.end,\n            value: vnode.attrs.data.period.end,\n            valueChanged: (value) => {\n              vnode.attrs.data.period.end = value\n              if (vnode.attrs.data.period.start > value) {\n                vnode.attrs.data.period.start = value\n              }\n              vnode.attrs.formUpdated(vnode.attrs.data)\n            }\n          })\n        ])\n      ]),\n      m('div', [\n        m('label', {\n          class: 'filter-label'\n        }, 'Laat kaarten zien die het midden van onderstaande kaart doorkruisen:'),\n        m('div', {\n          class: 'filter'\n        }, [\n          m(GeoIntersects, {\n            coordinatesUpdated: (coordinates) => {\n              vnode.attrs.data.coordinates = {\n                lat: coordinates.lat,\n                lng: coordinates.lng\n              }\n              vnode.attrs.formUpdated(vnode.attrs.data)\n              m.redraw()\n            }\n          })\n        ])\n      ]),\n      m('div', {\n        class: 'section-footer',\n      }, [\n        m(ExecuteButton)\n      ])\n    ])\n  ])\n}\n\nconst Map = {\n  view: () => m('div', {\n    id: 'map'\n  }),\n  oncreate: (vnode) => {\n    const map = L.map('map').setView([52.37064, 4.90047], 14)\n\n    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {\n      attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> &copy; <a href=\"http://cartodb.com/attributions\">CartoDB</a>',\n      subdomains: 'abcd',\n      maxZoom: 19\n    }).addTo(map)\n\n    map.on('moveend', (event) => {\n      if (vnode.attrs.moveEnd) {\n        vnode.attrs.moveEnd(map.getCenter())\n      }\n    })\n  }\n}\n\nconst Sparql = {\n  data: {\n    editor: undefined\n  },\n  view: (vnode) => m('li', [\n    m('h2', 'SPARQL-query'),\n    m('textarea', {\n      id: 'sparql-query'\n    }, createMapsQuery(vnode.attrs.data)),\n    m('div', {\n      class: 'section-footer'\n    }, [\n      m('a', {\n        target: '_blank',\n        href: `${SPARQL_HREF}#query=${encodeURIComponent(createMapsQuery(vnode.attrs.data))}&` +\n        `contentTypeConstruct=text%2Fturtle&contentTypeSelect=application%2Fsparql-results%2Bjson&` +\n        `endpoint=${encodeURIComponent(SPARQL_ENDPOINT)}&requestMethod=POST&tabTitle=Query&` +\n        `headers=%7B%7D&outputFormat=table`\n      }, 'Open query in AdamLink'),\n      m(ExecuteButton, {\n        onclick: () => {\n          vnode.attrs.executeMapsQuery()\n        }\n      })\n    ])\n  ]),\n  oncreate: (vnode) => {\n    const element = document.getElementById('sparql-query')\n\n    const editor = CodeMirror.fromTextArea(element, {\n      lineNumbers: true,\n      readOnly: true,\n      mode: 'sparql',\n      foldGutter: true,\n      gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter']\n    })\n\n    editor.foldCode(CodeMirror.Pos(0, 0))\n    vnode.state.data.editor = editor\n  },\n  onupdate: (vnode) => {\n    const editor = vnode.state.data.editor\n    editor.setValue(createMapsQuery(vnode.attrs.data))\n    editor.foldCode(CodeMirror.Pos(0, 0))\n  }\n}\n\nfunction renderResults (data, executeMapsQuery) {\n  if (data && data.length) {\n    return m('ol', {\n      id: 'results'\n    }, data.map((result) => m('li', [\n      m('div', {\n        class: 'result-values'\n      }, [\n        m('h3', {\n          class: 'truncate',\n          title: result.title.value\n        }, result.title.value),\n        m('span', result.begin.value.slice(0, 4))\n      ]),\n      m('div', {\n        class: 'result-values'\n      }, [\n        m('span', {\n          class: 'truncate',\n        }, result.provenance.value),\n        m('span', {\n          class: 'truncate'\n        }, result.creator.value)\n      ]),\n      m('a', {\n        href: result.map.value\n      }, [\n        m('img', {\n          src: result.img.value\n        })\n      ])\n    ])))\n  } else {\n    return m('p', [\n      m('span', 'Geen resultaten; '),\n      m(ExecuteButton, {\n        onclick: () => {\n          executeMapsQuery()\n        }\n      }),\n      m('span', ' of pas parameters aan.')\n    ])\n  }\n}\n\nconst Results =  {\n  view: (vnode) => m('li', [\n    m('h2', 'Resultaten'),\n    renderResults(vnode.attrs.data, vnode.attrs.executeMapsQuery)\n  ])\n}\n\nfunction executeMapsQuery (vnode) {\n  const query = createMapsQuery(vnode.state.data.form)\n  executeQuery(query)\n    .then((results) => {\n      Object.assign(vnode.state.data, {results})\n      m.redraw()\n    })\n}\n\nconst App = {\n  data: {\n    results: undefined,\n    form: {\n      period: Object.assign({}, PERIOD_BOUNDS),\n      coordinates: {\n        lat: 52.37064,\n        lng: 4.90047\n      },\n      collections: [],\n      creator: ''\n    }\n  },\n  view: (vnode) => ([\n    m('header', [\n      m('img', {\n        src: 'images/header.jpg'\n      }),\n      m('h1', 'Kaart-SPARQL')\n    ]),\n    m('main', [\n      m('p', 'Hier komt de introductie!'),\n      m('ol', {\n        class: 'sections'\n      }, [\n        m(Form, {\n          data: vnode.state.data.form,\n          formUpdated: (form) => Object.assign(vnode.state.data, form),\n          executeMapsQuery: () => executeMapsQuery(vnode)\n        }),\n        m(Sparql, {\n          data: vnode.state.data.form,\n          executeMapsQuery: () => executeMapsQuery(vnode)\n        }),\n        m(Results, {\n          data: vnode.state.data.results,\n          executeMapsQuery: () => executeMapsQuery(vnode)\n        })\n      ])\n    ])\n  ])\n}\n\nm.mount(document.body, App)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTUEFSUUxfRU5EUE9JTlQgPSAnaHR0cHM6Ly9kYXRhLmFkYW1saW5rLm5sL19hcGkvZGF0YXNldHMvbWVubm8vYWxsZXMvc2VydmljZXMvYWxsZXMvc3BhcnFsJ1xuLy8gY29uc3QgU1BBUlFMX0VORFBPSU5UID0gJ2h0dHBzOi8vZGF0YS5hZGFtbGluay5ubC9BZGFtTmV0L2FsbC9zZXJ2aWNlcy9lbmRwb2ludCdcbmNvbnN0IFNQQVJRTF9IUkVGID0gJ2h0dHBzOi8vZGF0YS5hZGFtbGluay5ubC9BZGFtTmV0L2FsbC9zZXJ2aWNlcy9lbmRwb2ludCdcblxuY29uc3QgUFJFRklYRVMgPSBgUFJFRklYIGRjOiA8aHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8+XG5QUkVGSVggZGN0OiA8aHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zLz5cblBSRUZJWCBnZW86IDxodHRwOi8vd3d3Lm9wZW5naXMubmV0L29udC9nZW9zcGFycWwjPlxuUFJFRklYIHNlbTogPGh0dHA6Ly9zZW1hbnRpY3dlYi5jcy52dS5ubC8yMDA5LzExL3NlbS8+XG5QUkVGSVggZm9hZjogPGh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvPlxuUFJFRklYIHdkdDogPGh0dHA6Ly93d3cud2lraWRhdGEub3JnL3Byb3AvZGlyZWN0Lz5cbmAudHJpbSgpXG5cblBFUklPRF9CT1VORFMgPSB7XG4gIHN0YXJ0OiAxNTUwLFxuICBlbmQ6IChuZXcgRGF0ZSgpKS5nZXRGdWxsWWVhcigpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHNRdWVyeSAoZGF0YSkge1xuICBjb25zdCByb3VuZCA9IChudW0pID0+IE1hdGgucm91bmQobnVtICogMTAwMDAwKSAvIDEwMDAwMFxuXG4gIGxldCBjb2xsZWN0aW9uc0ZpbHRlciA9ICcnXG4gIGlmIChkYXRhLmNvbGxlY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbGxlY3Rpb25zRmlsdGVyID0gYD9tYXAgZGN0OnByb3ZlbmFuY2UgXCIke2RhdGEuY29sbGVjdGlvbnNbMF19XCJeXnhzZDpzdHJpbmcgLlxcbmBcbiAgfSBlbHNlIGlmIChkYXRhLmNvbGxlY3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzdHJpbmdzID0gYCR7ZGF0YS5jb2xsZWN0aW9ucy5tYXAoY29sbGVjdGlvbiA9PiBgICAgIFwiJHtjb2xsZWN0aW9ufVwiXl54c2Q6c3RyaW5nYCkuam9pbignLFxcbicpfWBcbiAgICBjb2xsZWN0aW9uc0ZpbHRlciA9IGBcXG4gIEZJTFRFUiAoP3Byb3ZlbmFuY2UgSU4gKFxcbiR7c3RyaW5nc30pXFxuICApIC5gXG4gIH1cblxuICBsZXQgY3JlYXRvckZpbHRlciA9ICcnXG4gIGlmIChkYXRhLmNyZWF0b3IubGVuZ3RoID4gMSkge1xuICAgIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgY29uc3QgcmVnZXggPSBkYXRhLmNyZWF0b3IucmVwbGFjZSgvXFxcXChbXFxzXFxTXSl8KFwiKS9nLCAnXFxcXCQxJDInKVxuICAgIGNyZWF0b3JGaWx0ZXIgPSBgRklMVEVSIFJFR0VYKD9jcmVhdG9yLCBcIiR7cmVnZXh9XCIsIFwiaVwiKSAuYFxuICB9XG5cbiAgcmV0dXJuIGAke1BSRUZJWEVTfVxuXG5TRUxFQ1QgP21hcCA/aW1nID90aXRsZSA/cHJvdmVuYW5jZSA/Y3JlYXRvciA/YmVnaW4ge1xuICA/bWFwIGRjdDpzcGF0aWFsID9zcGF0aWFsIC5cbiAgP21hcCBmb2FmOmRlcGljdGlvbiA/aW1nIC5cbiAgP21hcCBkYzp0aXRsZSA/dGl0bGUgLlxuICA/bWFwIGRjdDpwcm92ZW5hbmNlID9wcm92ZW5hbmNlIC5cbiAgP21hcCBkYzpjcmVhdG9yID9jcmVhdG9yIC5cbiAgP21hcCBzZW06aGFzQmVnaW5UaW1lU3RhbXAgP2JlZ2luIC5cblxuICA/c3BhdGlhbCBkYzp0eXBlIFwib3V0bGluZVwiXl54c2Q6c3RyaW5nIC5cbiAgP3NwYXRpYWwgZ2VvOmhhc0dlb21ldHJ5L2dlbzphc1dLVCA/d2t0IC5cbiAgP3NwYXRpYWwgd2R0OlAyMDQ2ID9rbTIgLlxuICAke2NvbGxlY3Rpb25zRmlsdGVyfVxuICAke2NyZWF0b3JGaWx0ZXJ9XG4gIEZJTFRFUiAoeWVhcih4c2Q6ZGF0ZVRpbWUoP2JlZ2luKSkgPj0gJHtkYXRhLnBlcmlvZC5zdGFydH0pIC5cbiAgRklMVEVSICh5ZWFyKHhzZDpkYXRlVGltZSg/YmVnaW4pKSA8PSAke2RhdGEucGVyaW9kLmVuZH0pIC5cbiAgYmluZCAoYmlmOnN0X2dlb21mcm9tdGV4dChcIlBPSU5UKCR7cm91bmQoZGF0YS5jb29yZGluYXRlcy5sbmcpfSAke3JvdW5kKGRhdGEuY29vcmRpbmF0ZXMubGF0KX0pXCIpIGFzID9wb2ludClcbiAgYmluZCAoYmlmOnN0X2dlb21mcm9tdGV4dCg/d2t0KSBhcyA/b3V0bGluZSlcbiAgRklMVEVSIChiaWY6c3RfaW50ZXJzZWN0cyg/cG9pbnQsID9vdXRsaW5lKSlcbn1cbk9SREVSIEJZIEFTQyg/a20yKVxuTElNSVQgMjVgLnRyaW0oKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uc1F1ZXJ5ICgpIHtcbiAgcmV0dXJuIGAke1BSRUZJWEVTfVxuXG5TRUxFQ1QgRElTVElOQ1QgP3Byb3ZlbmFuY2UgKENPVU5UKD9tYXApIEFTID9jb3VudCkgV0hFUkUge1xuICA/bWFwIGRjdDpzcGF0aWFsID9zcGF0aWFsIC5cbiAgP21hcCBmb2FmOmRlcGljdGlvbiA/aW1nIC5cbiAgP21hcCBkYzp0aXRsZSA/dGl0bGUgLlxuICA/bWFwIHNlbTpoYXNCZWdpblRpbWVTdGFtcCA/YmVnaW4gLlxuICA/bWFwIGRjdDpwcm92ZW5hbmNlID9wcm92ZW5hbmNlIC5cblxuICA/c3BhdGlhbCBkYzp0eXBlIFwib3V0bGluZVwiXl54c2Q6c3RyaW5nIC5cbiAgP3NwYXRpYWwgZ2VvOmhhc0dlb21ldHJ5L2dlbzphc1dLVCA/d2t0IC5cbiAgP3NwYXRpYWwgd2R0OlAyMDQ2ID9rbTIgLlxufVxuR1JPVVAgQlkgP3Byb3ZlbmFuY2Vcbk9SREVSIEJZIERFU0MoP2NvdW50KVxuTElNSVQgMTAwXG5gLnRyaW0oKVxufVxuXG5mdW5jdGlvbiBleGVjdXRlUXVlcnkgKHF1ZXJ5KSB7XG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbS5idWlsZFF1ZXJ5U3RyaW5nKHtcbiAgICBxdWVyeVxuICB9KVxuXG4gIHJldHVybiBmZXRjaChTUEFSUUxfRU5EUE9JTlQsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBxdWVyeVN0cmluZyxcbiAgICBqc29uOiB0cnVlLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMranNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCdcbiAgICB9XG4gIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ0V4ZWN1dGluZyBxdWVyeSBmYWlsZWQnLCBlcnIpKVxuICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgIC50aGVuKChqc29uKSA9PiBqc29uLnJlc3VsdHMuYmluZGluZ3MpXG4gICAgLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ1BhcnNpbmcgcmVzdWx0cyBmYWlsZWQnLCBlcnIpKVxufVxuXG5jb25zdCBSYW5nZVNsaWRlciA9IHtcbiAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgb25jcmVhdGU6ICh2bm9kZSkgPT4gT2JqZWN0LmFzc2lnbih2bm9kZS5zdGF0ZSwge1xuICAgIHZhbHVlOiB2bm9kZS5hdHRycy52YWx1ZVxuICB9KSxcbiAgdmlldzogKHZub2RlKSA9PiBtKCdkaXYnLCB7XG4gICAgY2xhc3M6ICdyYW5nZS1zbGlkZXInXG4gIH0sIFtcbiAgICBtKCdsYWJlbCcsIHtcbiAgICAgIGZvcjogYHJhbmdlLXNsaWRlci0ke3Zub2RlLmF0dHJzLmlkfWBcbiAgICB9LCBgJHt2bm9kZS5hdHRycy5sYWJlbH0gJHt2bm9kZS5hdHRycy52YWx1ZX1gKSxcbiAgICBtKCdpbnB1dCcsIHtcbiAgICAgIGlkOiBgcmFuZ2Utc2xpZGVyLSR7dm5vZGUuYXR0cnMuaWR9YCxcbiAgICAgIHR5cGU6ICdyYW5nZScsXG4gICAgICBtaW46IHZub2RlLmF0dHJzLnN0YXJ0LFxuICAgICAgbWF4OiB2bm9kZS5hdHRycy5lbmQsXG4gICAgICB2YWx1ZTogdm5vZGUuYXR0cnMudmFsdWUsXG4gICAgICBvbmlucHV0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUpXG4gICAgICAgIHZub2RlLmF0dHJzLnZhbHVlQ2hhbmdlZCh2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICBdKVxufVxuXG5jb25zdCBDb2xsZWN0aW9uc1NlbGVjdCA9IHtcbiAgY29sbGVjdGlvbnM6IHVuZGVmaW5lZCxcbiAgdmlldzogKHZub2RlKSA9PiBbXG4gICAgbSgnZmllbGRzZXQnLCB7XG4gICAgICBpZDogJ2Zvcm0tY29sbGVjdGlvbnMnLFxuICAgICAgb25jaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja0JveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1mb3JtLWNvbGxlY3Rpb25zLWNoZWNrYm94XTpjaGVja2VkJylcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGNoZWNrQm94ZXMsIChjaGVja2JveCkgPT4gY2hlY2tib3gudmFsdWUpXG5cbiAgICAgICAgdm5vZGUuYXR0cnMuY29sbGVjdGlvbnNVcGRhdGVkKHZhbHVlcylcbiAgICAgIH1cbiAgICB9LCB2bm9kZS5zdGF0ZS5jb2xsZWN0aW9ucyAmJiB2bm9kZS5zdGF0ZS5jb2xsZWN0aW9ucy5tYXAoKGNvbGxlY3Rpb24sIGluZGV4KSA9PlxuICAgICAgbSgnZGl2JywgW1xuICAgICAgICBtKCdpbnB1dCcsIHtcbiAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgIG5hbWU6ICdmb3JtLWNvbGxlY3Rpb25zLWNoZWNrYm94JyxcbiAgICAgICAgICBpZDogYGZvcm0tY29sbGVjdGlvbnMtY2hlY2tib3gtJHtpbmRleH1gLFxuICAgICAgICAgIHZhbHVlOiBjb2xsZWN0aW9uLnByb3ZlbmFuY2UudmFsdWVcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2xhYmVsJywge1xuICAgICAgICAgIGZvcjogYGZvcm0tY29sbGVjdGlvbnMtY2hlY2tib3gtJHtpbmRleH1gLFxuICAgICAgICB9LCBbXG4gICAgICAgICAgbSgnc3BhbicsIGNvbGxlY3Rpb24ucHJvdmVuYW5jZS52YWx1ZSksXG4gICAgICAgICAgbSgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsYXNzOiAnZm9ybS1jb2xsZWN0aW9ucy1tYXAtY291bnQnXG4gICAgICAgICAgfSwgYCR7Y29sbGVjdGlvbi5jb3VudC52YWx1ZX0gJHtwYXJzZUludChjb2xsZWN0aW9uLmNvdW50LnZhbHVlKSA9PT0gMSA/ICdrYWFydCcgOiAna2FhcnRlbid9YClcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgKSlcbiAgXSxcbiAgb25jcmVhdGU6ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IHF1ZXJ5ID0gY3JlYXRlQ29sbGVjdGlvbnNRdWVyeSgpXG4gICAgZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnRoZW4oKGNvbGxlY3Rpb25zKSA9PiB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odm5vZGUuc3RhdGUsIHtjb2xsZWN0aW9uc30pXG4gICAgICAgIG0ucmVkcmF3KClcbiAgICAgIH0pXG4gIH1cbn1cblxuY29uc3QgRXhlY3V0ZUJ1dHRvbiA9IHtcbiAgdmlldzogKHZub2RlKSA9PiBtKCdidXR0b24nLCB7XG4gICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgb25jbGljazogKGV2ZW50KSA9PiB7XG4gICAgICBpZiAodm5vZGUuYXR0cnMub25jbGljaykge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmNsaWNrKGV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgJ+KWtiBWb2VyIHF1ZXJ5IHVpdCcpXG59XG5cbmNvbnN0IEdlb0ludGVyc2VjdHMgPSB7XG4gIHZpZXc6ICh2bm9kZSkgPT4gbSgnZGl2Jywge1xuICAgIGlkOiAnbWFwLWNvbnRhaW5lcidcbiAgfSwgW1xuICAgIG0oTWFwLCB7XG4gICAgICBtb3ZlRW5kOiB2bm9kZS5hdHRycy5jb29yZGluYXRlc1VwZGF0ZWRcbiAgICB9KSxcbiAgICBtKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ21hcC1jcm9zc2hhaXInXG4gICAgfSwgW1xuICAgICAgbSgnaW1nJywge1xuICAgICAgICBzcmM6ICdpbWFnZXMvY3Jvc3NoYWlyLnN2ZydcbiAgICAgIH0pXG4gICAgXSlcbiAgXSlcbn1cblxuY29uc3QgRm9ybSA9IHtcbiAgdmlldzogKHZub2RlKSA9PiBtKCdsaScsIFtcbiAgICBtKCdoMicsICdQYXJhbWV0ZXJzJyksXG4gICAgbSgnZm9ybScsIHtcbiAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB2bm9kZS5hdHRycy5leGVjdXRlTWFwc1F1ZXJ5KClcbiAgICAgIH1cbiAgICB9LCBbXG4gICAgICBtKCdkaXYnLCBbXG4gICAgICAgIG0oJ2xhYmVsJywge1xuICAgICAgICAgIGZvcjogJ2Zvcm0tY29sbGVjdGlvbnMnLFxuICAgICAgICAgIGNsYXNzOiAnZmlsdGVyLWxhYmVsJ1xuICAgICAgICB9LCAnTGFhdCBrYWFydGVuIHVpdCBkZXplIGNvbGxlY3RpZXMgemllbjonKSxcbiAgICAgICAgbSgnZGl2Jywge1xuICAgICAgICAgIGNsYXNzOiAnZmlsdGVyJ1xuICAgICAgICB9LCBbXG4gICAgICAgICAgbShDb2xsZWN0aW9uc1NlbGVjdCwge1xuICAgICAgICAgICAgY29sbGVjdGlvbnNVcGRhdGVkOiAoY29sbGVjdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuZGF0YS5jb2xsZWN0aW9ucyA9IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgIHZub2RlLmF0dHJzLmZvcm1VcGRhdGVkKHZub2RlLmF0dHJzLmRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgbSgnZGl2JywgW1xuICAgICAgICBtKCdsYWJlbCcsIHtcbiAgICAgICAgICBjbGFzczogJ2ZpbHRlci1sYWJlbCdcbiAgICAgICAgfSwgJ0xhYXQga2FhcnRlbiB2YW4gZGV6ZSBtYWtlciB6aWVuOicpLFxuICAgICAgICBtKCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdmaWx0ZXInXG4gICAgICAgIH0sIFtcbiAgICAgICAgICBtKCdpbnB1dCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiB2bm9kZS5hdHRycy5kYXRhLmNyZWF0b3IsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBvbmlucHV0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuZGF0YS5jcmVhdG9yID0gdmFsdWVcbiAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuZm9ybVVwZGF0ZWQodm5vZGUuYXR0cnMuZGF0YSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbGFjZUhvbGRlcjogJ1pvZWsgb3AgZXhhY3RlIHRla3N0LCBvZiBnZWJydWlrIGVlbiByZWd1bGllcmUgZXhwcmVzc2llJ1xuICAgICAgICAgIH0pXG4gICAgICAgIF0pXG4gICAgICBdKSxcbiAgICAgIG0oJ2RpdicsIFtcbiAgICAgICAgbSgnbGFiZWwnLCB7XG4gICAgICAgICAgY2xhc3M6ICdmaWx0ZXItbGFiZWwnXG4gICAgICAgIH0sICdMYWF0IGthYXJ0ZW4gemllbiB1aXQgZGV6ZSBwZXJpb2RlOicpLFxuICAgICAgICBtKCdkaXYnLCB7XG4gICAgICAgICAgaWQ6ICdwZXJpb2QtZmlsdGVyJyxcbiAgICAgICAgICBjbGFzczogJ2ZpbHRlcidcbiAgICAgICAgfSwgW1xuICAgICAgICAgIG0oUmFuZ2VTbGlkZXIsIHtcbiAgICAgICAgICAgIGlkOiAnc3RhcnQnLFxuICAgICAgICAgICAgbGFiZWw6ICdWYW4nLFxuICAgICAgICAgICAgc3RhcnQ6IFBFUklPRF9CT1VORFMuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IFBFUklPRF9CT1VORFMuZW5kLFxuICAgICAgICAgICAgdmFsdWU6IHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLnN0YXJ0LFxuICAgICAgICAgICAgdmFsdWVDaGFuZ2VkOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICB2bm9kZS5hdHRycy5kYXRhLnBlcmlvZC5zdGFydCA9IHZhbHVlXG4gICAgICAgICAgICAgaWYgKHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLmVuZCA8IHZhbHVlKSB7XG4gICAgICAgICAgICAgICB2bm9kZS5hdHRycy5kYXRhLnBlcmlvZC5lbmQgPSB2YWx1ZVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB2bm9kZS5hdHRycy5mb3JtVXBkYXRlZCh2bm9kZS5hdHRycy5kYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG0oUmFuZ2VTbGlkZXIsIHtcbiAgICAgICAgICAgIGlkOiAnZW5kJyxcbiAgICAgICAgICAgIGxhYmVsOiAnOyB0b3QnLFxuICAgICAgICAgICAgc3RhcnQ6IFBFUklPRF9CT1VORFMuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IFBFUklPRF9CT1VORFMuZW5kLFxuICAgICAgICAgICAgdmFsdWU6IHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLmVuZCxcbiAgICAgICAgICAgIHZhbHVlQ2hhbmdlZDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHZub2RlLmF0dHJzLmRhdGEucGVyaW9kLmVuZCA9IHZhbHVlXG4gICAgICAgICAgICAgIGlmICh2bm9kZS5hdHRycy5kYXRhLnBlcmlvZC5zdGFydCA+IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuZGF0YS5wZXJpb2Quc3RhcnQgPSB2YWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZub2RlLmF0dHJzLmZvcm1VcGRhdGVkKHZub2RlLmF0dHJzLmRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgbSgnZGl2JywgW1xuICAgICAgICBtKCdsYWJlbCcsIHtcbiAgICAgICAgICBjbGFzczogJ2ZpbHRlci1sYWJlbCdcbiAgICAgICAgfSwgJ0xhYXQga2FhcnRlbiB6aWVuIGRpZSBoZXQgbWlkZGVuIHZhbiBvbmRlcnN0YWFuZGUga2FhcnQgZG9vcmtydWlzZW46JyksXG4gICAgICAgIG0oJ2RpdicsIHtcbiAgICAgICAgICBjbGFzczogJ2ZpbHRlcidcbiAgICAgICAgfSwgW1xuICAgICAgICAgIG0oR2VvSW50ZXJzZWN0cywge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXNVcGRhdGVkOiAoY29vcmRpbmF0ZXMpID0+IHtcbiAgICAgICAgICAgICAgdm5vZGUuYXR0cnMuZGF0YS5jb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgICAgICBsYXQ6IGNvb3JkaW5hdGVzLmxhdCxcbiAgICAgICAgICAgICAgICBsbmc6IGNvb3JkaW5hdGVzLmxuZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZub2RlLmF0dHJzLmZvcm1VcGRhdGVkKHZub2RlLmF0dHJzLmRhdGEpXG4gICAgICAgICAgICAgIG0ucmVkcmF3KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBtKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAnc2VjdGlvbi1mb290ZXInLFxuICAgICAgfSwgW1xuICAgICAgICBtKEV4ZWN1dGVCdXR0b24pXG4gICAgICBdKVxuICAgIF0pXG4gIF0pXG59XG5cbmNvbnN0IE1hcCA9IHtcbiAgdmlldzogKCkgPT4gbSgnZGl2Jywge1xuICAgIGlkOiAnbWFwJ1xuICB9KSxcbiAgb25jcmVhdGU6ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IEwubWFwKCdtYXAnKS5zZXRWaWV3KFs1Mi4zNzA2NCwgNC45MDA0N10sIDE0KVxuXG4gICAgTC50aWxlTGF5ZXIoJ2h0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy17c30uZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X2FsbC97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICBhdHRyaWJ1dGlvbjogJyZjb3B5OyA8YSBocmVmPVwiaHR0cDovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiAmY29weTsgPGEgaHJlZj1cImh0dHA6Ly9jYXJ0b2RiLmNvbS9hdHRyaWJ1dGlvbnNcIj5DYXJ0b0RCPC9hPicsXG4gICAgICBzdWJkb21haW5zOiAnYWJjZCcsXG4gICAgICBtYXhab29tOiAxOVxuICAgIH0pLmFkZFRvKG1hcClcblxuICAgIG1hcC5vbignbW92ZWVuZCcsIChldmVudCkgPT4ge1xuICAgICAgaWYgKHZub2RlLmF0dHJzLm1vdmVFbmQpIHtcbiAgICAgICAgdm5vZGUuYXR0cnMubW92ZUVuZChtYXAuZ2V0Q2VudGVyKCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBTcGFycWwgPSB7XG4gIGRhdGE6IHtcbiAgICBlZGl0b3I6IHVuZGVmaW5lZFxuICB9LFxuICB2aWV3OiAodm5vZGUpID0+IG0oJ2xpJywgW1xuICAgIG0oJ2gyJywgJ1NQQVJRTC1xdWVyeScpLFxuICAgIG0oJ3RleHRhcmVhJywge1xuICAgICAgaWQ6ICdzcGFycWwtcXVlcnknXG4gICAgfSwgY3JlYXRlTWFwc1F1ZXJ5KHZub2RlLmF0dHJzLmRhdGEpKSxcbiAgICBtKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3NlY3Rpb24tZm9vdGVyJ1xuICAgIH0sIFtcbiAgICAgIG0oJ2EnLCB7XG4gICAgICAgIHRhcmdldDogJ19ibGFuaycsXG4gICAgICAgIGhyZWY6IGAke1NQQVJRTF9IUkVGfSNxdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChjcmVhdGVNYXBzUXVlcnkodm5vZGUuYXR0cnMuZGF0YSkpfSZgICtcbiAgICAgICAgYGNvbnRlbnRUeXBlQ29uc3RydWN0PXRleHQlMkZ0dXJ0bGUmY29udGVudFR5cGVTZWxlY3Q9YXBwbGljYXRpb24lMkZzcGFycWwtcmVzdWx0cyUyQmpzb24mYCArXG4gICAgICAgIGBlbmRwb2ludD0ke2VuY29kZVVSSUNvbXBvbmVudChTUEFSUUxfRU5EUE9JTlQpfSZyZXF1ZXN0TWV0aG9kPVBPU1QmdGFiVGl0bGU9UXVlcnkmYCArXG4gICAgICAgIGBoZWFkZXJzPSU3QiU3RCZvdXRwdXRGb3JtYXQ9dGFibGVgXG4gICAgICB9LCAnT3BlbiBxdWVyeSBpbiBBZGFtTGluaycpLFxuICAgICAgbShFeGVjdXRlQnV0dG9uLCB7XG4gICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICB2bm9kZS5hdHRycy5leGVjdXRlTWFwc1F1ZXJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdKVxuICBdKSxcbiAgb25jcmVhdGU6ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BhcnFsLXF1ZXJ5JylcblxuICAgIGNvbnN0IGVkaXRvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGVsZW1lbnQsIHtcbiAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICBtb2RlOiAnc3BhcnFsJyxcbiAgICAgIGZvbGRHdXR0ZXI6IHRydWUsXG4gICAgICBndXR0ZXJzOiBbJ0NvZGVNaXJyb3ItbGluZW51bWJlcnMnLCAnQ29kZU1pcnJvci1mb2xkZ3V0dGVyJ11cbiAgICB9KVxuXG4gICAgZWRpdG9yLmZvbGRDb2RlKENvZGVNaXJyb3IuUG9zKDAsIDApKVxuICAgIHZub2RlLnN0YXRlLmRhdGEuZWRpdG9yID0gZWRpdG9yXG4gIH0sXG4gIG9udXBkYXRlOiAodm5vZGUpID0+IHtcbiAgICBjb25zdCBlZGl0b3IgPSB2bm9kZS5zdGF0ZS5kYXRhLmVkaXRvclxuICAgIGVkaXRvci5zZXRWYWx1ZShjcmVhdGVNYXBzUXVlcnkodm5vZGUuYXR0cnMuZGF0YSkpXG4gICAgZWRpdG9yLmZvbGRDb2RlKENvZGVNaXJyb3IuUG9zKDAsIDApKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJlc3VsdHMgKGRhdGEsIGV4ZWN1dGVNYXBzUXVlcnkpIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbSgnb2wnLCB7XG4gICAgICBpZDogJ3Jlc3VsdHMnXG4gICAgfSwgZGF0YS5tYXAoKHJlc3VsdCkgPT4gbSgnbGknLCBbXG4gICAgICBtKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAncmVzdWx0LXZhbHVlcydcbiAgICAgIH0sIFtcbiAgICAgICAgbSgnaDMnLCB7XG4gICAgICAgICAgY2xhc3M6ICd0cnVuY2F0ZScsXG4gICAgICAgICAgdGl0bGU6IHJlc3VsdC50aXRsZS52YWx1ZVxuICAgICAgICB9LCByZXN1bHQudGl0bGUudmFsdWUpLFxuICAgICAgICBtKCdzcGFuJywgcmVzdWx0LmJlZ2luLnZhbHVlLnNsaWNlKDAsIDQpKVxuICAgICAgXSksXG4gICAgICBtKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAncmVzdWx0LXZhbHVlcydcbiAgICAgIH0sIFtcbiAgICAgICAgbSgnc3BhbicsIHtcbiAgICAgICAgICBjbGFzczogJ3RydW5jYXRlJyxcbiAgICAgICAgfSwgcmVzdWx0LnByb3ZlbmFuY2UudmFsdWUpLFxuICAgICAgICBtKCdzcGFuJywge1xuICAgICAgICAgIGNsYXNzOiAndHJ1bmNhdGUnXG4gICAgICAgIH0sIHJlc3VsdC5jcmVhdG9yLnZhbHVlKVxuICAgICAgXSksXG4gICAgICBtKCdhJywge1xuICAgICAgICBocmVmOiByZXN1bHQubWFwLnZhbHVlXG4gICAgICB9LCBbXG4gICAgICAgIG0oJ2ltZycsIHtcbiAgICAgICAgICBzcmM6IHJlc3VsdC5pbWcudmFsdWVcbiAgICAgICAgfSlcbiAgICAgIF0pXG4gICAgXSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtKCdwJywgW1xuICAgICAgbSgnc3BhbicsICdHZWVuIHJlc3VsdGF0ZW47ICcpLFxuICAgICAgbShFeGVjdXRlQnV0dG9uLCB7XG4gICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICBleGVjdXRlTWFwc1F1ZXJ5KClcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBtKCdzcGFuJywgJyBvZiBwYXMgcGFyYW1ldGVycyBhYW4uJylcbiAgICBdKVxuICB9XG59XG5cbmNvbnN0IFJlc3VsdHMgPSAge1xuICB2aWV3OiAodm5vZGUpID0+IG0oJ2xpJywgW1xuICAgIG0oJ2gyJywgJ1Jlc3VsdGF0ZW4nKSxcbiAgICByZW5kZXJSZXN1bHRzKHZub2RlLmF0dHJzLmRhdGEsIHZub2RlLmF0dHJzLmV4ZWN1dGVNYXBzUXVlcnkpXG4gIF0pXG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVNYXBzUXVlcnkgKHZub2RlKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gY3JlYXRlTWFwc1F1ZXJ5KHZub2RlLnN0YXRlLmRhdGEuZm9ybSlcbiAgZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KVxuICAgIC50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKHZub2RlLnN0YXRlLmRhdGEsIHtyZXN1bHRzfSlcbiAgICAgIG0ucmVkcmF3KClcbiAgICB9KVxufVxuXG5jb25zdCBBcHAgPSB7XG4gIGRhdGE6IHtcbiAgICByZXN1bHRzOiB1bmRlZmluZWQsXG4gICAgZm9ybToge1xuICAgICAgcGVyaW9kOiBPYmplY3QuYXNzaWduKHt9LCBQRVJJT0RfQk9VTkRTKSxcbiAgICAgIGNvb3JkaW5hdGVzOiB7XG4gICAgICAgIGxhdDogNTIuMzcwNjQsXG4gICAgICAgIGxuZzogNC45MDA0N1xuICAgICAgfSxcbiAgICAgIGNvbGxlY3Rpb25zOiBbXSxcbiAgICAgIGNyZWF0b3I6ICcnXG4gICAgfVxuICB9LFxuICB2aWV3OiAodm5vZGUpID0+IChbXG4gICAgbSgnaGVhZGVyJywgW1xuICAgICAgbSgnaW1nJywge1xuICAgICAgICBzcmM6ICdpbWFnZXMvaGVhZGVyLmpwZydcbiAgICAgIH0pLFxuICAgICAgbSgnaDEnLCAnS2FhcnQtU1BBUlFMJylcbiAgICBdKSxcbiAgICBtKCdtYWluJywgW1xuICAgICAgbSgncCcsICdIaWVyIGtvbXQgZGUgaW50cm9kdWN0aWUhJyksXG4gICAgICBtKCdvbCcsIHtcbiAgICAgICAgY2xhc3M6ICdzZWN0aW9ucydcbiAgICAgIH0sIFtcbiAgICAgICAgbShGb3JtLCB7XG4gICAgICAgICAgZGF0YTogdm5vZGUuc3RhdGUuZGF0YS5mb3JtLFxuICAgICAgICAgIGZvcm1VcGRhdGVkOiAoZm9ybSkgPT4gT2JqZWN0LmFzc2lnbih2bm9kZS5zdGF0ZS5kYXRhLCBmb3JtKSxcbiAgICAgICAgICBleGVjdXRlTWFwc1F1ZXJ5OiAoKSA9PiBleGVjdXRlTWFwc1F1ZXJ5KHZub2RlKVxuICAgICAgICB9KSxcbiAgICAgICAgbShTcGFycWwsIHtcbiAgICAgICAgICBkYXRhOiB2bm9kZS5zdGF0ZS5kYXRhLmZvcm0sXG4gICAgICAgICAgZXhlY3V0ZU1hcHNRdWVyeTogKCkgPT4gZXhlY3V0ZU1hcHNRdWVyeSh2bm9kZSlcbiAgICAgICAgfSksXG4gICAgICAgIG0oUmVzdWx0cywge1xuICAgICAgICAgIGRhdGE6IHZub2RlLnN0YXRlLmRhdGEucmVzdWx0cyxcbiAgICAgICAgICBleGVjdXRlTWFwc1F1ZXJ5OiAoKSA9PiBleGVjdXRlTWFwc1F1ZXJ5KHZub2RlKVxuICAgICAgICB9KVxuICAgICAgXSlcbiAgICBdKVxuICBdKVxufVxuXG5tLm1vdW50KGRvY3VtZW50LmJvZHksIEFwcClcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });